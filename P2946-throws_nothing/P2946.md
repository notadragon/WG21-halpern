% D2946R0: A flexible solution to the problems of `noexcept`
% Pablo Halpern <<phalpern@halpernwightsoftware.com>>
% <!-- $TimeStamp$ -->2023-07-09 21:47 EDT<!-- $ -->
Target audience: EWGI

Abstract
========

The `noexcept` function specifier and companion `noexcept` operator were
invented to allow containers such `vector` to provide the strong
exception-safety guarantee when performing operations that require relocating
existing elements. The `noexcept` specifier has since been utilized to improve
code generation and, sometimes, as a form of documentation.  The problems with
these off-label uses have been known for a long time; the so-called *Lakos
Rule*, which predated the release of C++11, was intended to prevent such use
(or misuse) within the C++ Standard Library.  In this paper, I propose an
annotation for non-throwing functions to be used instead of `noexcept` in
circumstances where the latter is undesirable -- specifically, when the
function in question has a *narrow contract*.  Although not part of the simple
and minimal proposal presented, this paper also explores how this alternative
nothrow facility could eventually be integrated with a future contracts
<!--
  MG: When I see "nothrow" here, there is an assumption it will be defined or 
      used as a keyword later. Consider using "throws_nothing" or even just
      omit completely "... this alternative facility ...".
 JMB: Wordier, but not introducing a new word: "alternative facility for  
      expressing that a function does not throw".  I agree that we should avoid
      coining 'nothrow' as a new term if we can avoid it
-->
facility.

Brief Summary
=============

I propose an annotation in the form of an attribute, `[[throws_nothing]]`,
indicating that a function does not throw when called properly (*in
contract*):

```C++
[[throws_nothing]] void f(int);
static_assert(noexcept(f(0)) == false);
```

Importantly, this proposed `[[throws_nothing]]` attribute, unlike the
`noexcept` specifier, is intentionally invisible to the `noexcept` operator; it
does not affect *essential behavior* and may be ignored by some platforms in
various build modes.
<!--
  MG: suggest "... by some platforms depending on the build mode.".
-->
`[[throws_nothing]]` can, therefore, be added or removed
<!--
  MG: suggest "... be added to or removed from ..." (ie extra "to").
-->
from a function declaration without affecting program logic.
<!--
 JMB: Should call out up front why an attribute might be right:

      As allowing exceptions to propagate as if the attribute were not
      there is a conforming implementation choice, the use of an attribute
      is consistent with the principles for attributes described in
      \cite{P2552R2}.
  -->      

An expanded description of this proposal is in the
[Proposed Feature](#proposed-feature) section.

Motivation
==========

Purpose of `noexcept`
---------------------

The `noexcept` specifier was introduced at the end of the C++11 cycle for one
purpose: to enable the safe use of move constructors in `vector`-like
containers that offer the *strong exception-safety guarantee* for certain
operations, such as inserting elements at the end.
<!--
  MG: missing "as"
-->
<!--
 JMB: I think this would be weighier with some citations to the papers that
      back up this claim.
-->       
Below is an approximate implementation of a vector-reallocation function, which
<!--
  MG: how is this "approximate" and do we need to say that ?
-->
must leave the original vector unchanged if an exception is thrown while trying
to move elements from the old buffer to the new one.

```C++
template <class T, class A>
void vector<T,A>::reallocate(size_type new_capacity)
{
  pointer new_data = allocator_traits<A>::allocate(new_capacity);

  size_type i = 0;
  if constexpr (noexcept(T(std::move(m_data[i]))))
    for (i = 0; i < size(); ++i)
      new (&new_data[i]) T(std::move(m_data[i]));  // Move (efficient)
  }
  else try {
    for (i = 0; i < size(); ++i)
      new (&new_data[i]) T(m_data[i]);  // Copy (less efficient)
  }
  catch (...) {
    while (i)
      new_data[--i].~T();
    allocator_traits<A>::deallocate(new_data, new_capacity);
    throw;
  }

  // Got here only if no exception was thrown
  for (i = 0; i < size(); ++i)
    m_data[i].~T();
  allocator_traits<A>::deallocate(m_data, m_capacity);

  m_data     = new_data;
  m_capacity = new_capacity;
}
```

The use of `T`'s move constructor often yields significant performance
<!--
  JMB: making it "algorithmic performance advantages"?  The whole point is
       that it can turn O(n^2) or wrose to O(n) because you don't have to do
       deep copying.  Call that out - it's not just about a constant factor
       speedup.
-->
advantages over using its copy constructor, but the move constructor modifies
the original object; if the move constructor might throw, `vector` must revert
to the copy constructor, giving up the performance gain in order to ensure that
it can return the original object to its initial state. Because this is a
*generic context*, it would be impossible to use `std::move` and retain the
strong guarantee in the code above if we did not have the `noexcept` operator.

The Lakos Rule
--------------

Being late in the C++11 cycle, applying the brand-new, and not fully
understood, `noexcept` annotation appropriately in the standard library was a
challenge. John Lakos and Alisdair Meredith proposed what has become
known as the *Lakos Rule*.  Summarized below, the Lakos Rule provided a safe
framework for deciding whether a specific function should be declared
`noexcept`:
<!--
  JMB: Cite N3279.
       The first bullet was really "that the LWG agree cannot throw".
       There's also stuff about conditional noexcepts, and P0884 might be worth
       mentioning, but that's also a distraction from the main point.
-->

 * If it has no preconditions (a *wide contract*) and promises not to
   throw, then declare it `noexcept`.
 * If it has preconditions (a *narrow contract*) or it might
   throw when called correctly (*in contract*), then do not declare it
   `noexcept` (or declare it `noexcept(false)`).

In the example below, showing a subset of the `std::vector` interface. Note
<!--
  MG: This sentence is missing a verb. Did you mean "shows" not "showing"?
 JMB: Or is this one sentence and not two?  
-->
that only `size()`, which promises not to throw and has no preconditions, is
declared `noexcept` whereas `at` and `operator[]` fail one of the tests and is
<!--
  MG: s/is/are/
-->
thus not `noexcept`.

```C++
template <class T, class A>
class vector {
   // ...
   constexpr size_type size() const noexcept; // wide contract,   doesn't throw
   constexpr reference at(size_type);         // wide contract,   might throw
   constexpr reference operator[](size_type); // narrow contract, doesn't throw
};
```

Resistance to the Lakos Rule
----------------------------

Although it is an effective rule, with strong theoretical and practical
underpinnings (see [Lakos23]()), two reasons have emerged for violating the
Lakos Rule in the Standard Library design:

 1. Under many (but by no means all) circumstances, calling a `noexcept` function
    generates less code.  Thus, programmers -- both within and outside of WG21
    -- want to use `noexcept` to improve code generation. It is important to
    note that I've seen no compelling evidence that `noexcept` produces
    measurably *faster* code with any modern compilers.

 2. Within WG21, it irks some people that a function is marked "*Throws*:
    nothing", yet does not have a `noexcept` annotation.
<!--
  MG: "irks some people" is quite pointed. Maybe use a more diplomatic phrasing?
 JMB: Cite P1656R0?   Maybe something like this:
      it has been brought up that there is an unclear
      distinction between "*Throws*: nothing" and `noexcept`
-->

As tempting as it might be, violating the Lakos rule is ill-advised unless a
compelling case can be made that querying the function with the `noexcept`
operator is necessary for compile-time optimization of an algorithm. As
described in [Lakos23](), if `noexcept` is added to a function in one version
of the Standard, it cannot be removed in future versions without potentially
breaking code.
<!--
  MG: Did you intend a paragraph break here?
-->
It is safe to widen the contract of a function to add new functionality,
provided that every program written for the old version will have the same
<!--
  MG: s/will have/has/ (consistent tense as you say "it *is* safe" at 
      the start of the sentence)?
-->
observable behavior when compiled with the new version. If the
old version is annotated with `noexcept`, however, the new version cannot be
widened to accept new values that would result in an exception being thrown.

Moveover, a defensive programming library or language contract facility might
want to throw an exception on a contract violation, especially when testing the
contract checks themselves.  The `noexcept` specifier interferes with such a
facility (see [Doumler23]()).


Proposed Feature
================

What is needed is a way to provide the desired code-generation and
documentation benefits of `noexcept` described in the
[Resistance to the Lakos Rule](resistance-to-the-lakos-rule) section without
violating either the spirit or the letter of the Lakos Rule. The goal is to
address the constituencies within the C++ "multiverse" that have been
ill-served by `noexcept` alone such as embedded developers who want smaller
code, and unit-testers who want to throw on contract violations.
<!--
  MG: missing "and"
-->

The proposed standard attribute, tentatively named `[[throws_nothing]]`,
indicates that a function promises not to throw when called in contract. If the
function exits via a thrown exception, the behavior is *implementation
defined*.  Critical to the `[[throws_nothing]]` feature is that its use cannot
be detected by the program itself at compile time; the result of the `noexcept`
operator is unchanged by this attribute. The `[[throws_nothing]]` attribute
does not change the type of the function and it cannot be used to select an
algorithm at compile time.
<!--
 JMB: Might be worth citing P2834 for why contract-checking enablement shouldn't
      impact the type or the noexcept operator?
  -->      

`[[throws_nothing]]` does not change the behavior of a correct program and can
be removed in future versions of a function, provided the behavior of the
function does not change for any previously valid inputs.  By making the
behavior of an incorrect program --- one that attempts to throw from a
`[[throws_nothing]]` function --- implementation defined, rather than
specifying an action such as `std::terminate()` or letting the behavior be
undefined, we allow the behavior to vary based on optimization level or other
compiler settings (*build modes*).

As with `noexcept`, implementations of the Standard Library would be permitted
to use `[[throws_nothing]]` for any non-throwing function, even if the Standard
itself does not mandate its use. In fact, `[[throws_nothing]]` is much better
for discretionary use by implementations than is the `noexcept` specifier
because it cannot inadvertently change the meaning of a program and is
responsive to the settings used to build the program.

<!--
  MG: In the above section you talk in detail about what [[throws_nothing]] does *not* 
      do but you could say more about what it *does* do or what purpose it serves.
      (codegen is barely mentioned except briefly in the first paragraph)
-->

Feature comparison
------------------

For functions that promise not to throw, the table below compares
`[[throws_nothing]]` against `noexcept` and nothing (using no nothrow
<!--
  MG: Again, using the word "nothrow" is confusing, as it is neither a valid word 
      nor a keyword. Suggest "using no annoation at all".
 JMB: I agree with Mungo on this
-->
annotation at all). The purpose of the table is not to show that one annotation
is better than the other, but that, despite some overlap, they serve different
purposes and therefore support different use cases, none of which violate the
Lakos Rule.

|                                           | nothing | `noexcept` | `[[throws_nothing]]` |
| ----------------------------------------- | ------- | ---------- | -------------------- |
| Provides function Documentation           | no      | yes        | yes                  |
| Provides codegen hint to compiler         | no      | yes        | yes                  |
| Terminates on unexpected exception        | no      | yes        | mode-dependent       |
| Allows recovery from unexpected exception | yes     | no         | mode-dependent       |
| Suitable for wide contracts               | yes     | yes        | yes                  |
| Suitable for narrow contracts             | yes     | no         | yes                  |
| Compatible with throwing defensive checks | yes     | no         | yes                  |
| Supports compile-time algorithm selection | no      | yes        | no                   |

<!--
  MG: "mode-dependent" in this table should probably be "implementation defined".
 JMB: "Provides function documentation" is confusing --- is "nothing" meant to be literally
       nothing, or is it meant to be "// Throws: Nothing" or some similar aspect of
       the human-language function contract?
       "Compatible with throwing defensive checks" is also potentially build-dependent
       unless we integrate more tightly with Contracts
-->

Build modes
-----------

Build modes are not part of the C++ standard, but their existence can be
implied. Initially, it would be expected (and encouraged) that every implementation
<!--
  MG: missing "be". Also by "expected" do you mean "expected but not mandated"?
-->
provide at least two build modes affecting the behavior of attempting to exit
a `[[throws_nothing]]` function via an exception:

1. **Terminate**: Call `std::terminate` just like `noexcept` does.

2. **Ignore/rethrow**: Allow the exception to escape, as though the annotation
   were not present.

There are other options, some of which are described in the
[Future Integration with Contracts](#future-integration-with-contracts)
section, below.

<!--
  JMB: I think you need to discuss the impact of mixed build modes on
       reality here.  If linking mixed modes like this is supported then you don't
       get the caller codegen benefits  when you don't know the build mode of
       the callee  (the caller still needs to support linking against something
       that will rethrow, and is not allowed to break stack unwinding so that becomes
       UB).
 -->       

Syntax and spelling
-------------------

While it would seem logical to put the `[[throws_nothing]]` attribute in the same
location as `noexcept`, in order for an attribute to appertain to a function, it
<!--
  MG: fixed spelling
-->
must go either before the function declaration or immediately after the
function identifier:

```C++
[[throws_nothing]] void f(int);   // OK
void g [[throws_nothing]] (int);  // OK
void h(int) [[throws_nothing]];   // Not proper attribute placement
```

The `[[throws_nothing]]` annotation fits well with the conventional notion of
an attribute: removing the attribute has no essential effect on a correct
program. Rending this functionality with a keyword or contextual keyword seems
unnecessary.

The original spelling for the attribute was `[[does_not_throw]]`, which happens
<!--
  MG: fixed spelling
-->
to be the same number of characters as `[[throws_nothing]]`. I do not have a
strong opinion on the better spelling, and am open to a poll on that question.
<!--
 JMB: I would list alternatives, but I would call out that this name
      matches what we put in the standard most and has not led to confusion
      with any that have seen it.
      Asking EWG or LEWG to bikeshed something without providing reaosnable
      input always seems to be a disaster
-->      

This paper does not propose the ability to make `[[does_not_throw]]`
conditional on a constant (Boolean) property, the way the `noexcept` clause
<!--
  MG: missing "on"
-->
can. Such functionality seems counter-intuitive, as there is deliberately no
<!--
  MG: "can" should be either "can be" or, better, "is".
-->
equivalent to the `noexcept` operator that could be used in such a context.  If
conditional functionality is desired (now or in the future), the syntax can be
extended with a parameter, i.e.,
`[[does_not_throw(` *boolean-expression* `)]]`.
<!--
 JMB: Call out that the parameter should be a compile-time constant?
      The relation to the noexcept operator is not obvious --- how about this:

      "Without the equivalent of the `noexcept` operator the most common case,
      having wrappers which propagate this attribute from wrapped functions
      by querying for it, is deliberately not implementable".
 -->


Alternatives Considered
=======================

Switching `noexcept` on and off with a constant expression
----------------------------------------------------------

One use of `[[does_not_throw]]` is to allow defensive checks to throw an
exception through an otherwise-nonthrowing interface. One proposed way to get
this behavior in certain build modes is to use `noexcept` in such a way that it
can be turned off for certain functions.  This approach can be implemented with
help of the preprocessor:

```C++
#ifdef CHECKED_MODE
inline constexpr bool does_not_throw = false;
#define ASSERT(cond) if (! (cond)) throw std::logic_error(#cond)
#else
inline constexpr bool does_not_throw = true;
#define ASSERT(cond) (void) 0
#endif

void f(int i) noexcept(does_not_throw)  // BAD IDEA!
{
  ASSERT(i < 0);
  // ...
}
```

With this approach, the expression `noexcept(f(0))` will yield different
results in different build modes, possibly resulting in different logic paths
for debug and release builds, and violating the imperative that essential
<!--
  MG: fixed spelling
-->
behavior is not changed by build modes.
<!-- JMB: Cite P2834 -->

Future Integration with Contracts
=================================

`[[throws_nothing]]` describes a sort of postcondition, i.e., that the function
did not exit via an exception. As the contract facility takes shape, the
`[[throws_nothing]]` facility could evolve in such a way as to make the
combination as powerful and consistent as possible.  Specifically,

<!--
  MG: The below bullets sound like just suggestions for possible future 
      discussion, but that fact is not entirely clear from the introductory 
      paragraph.
-->

* The contracts facility gives the programmer control, by means of a
<!--
  MG: Should "contracts" be "Contracts" (upper case C) ?
 JMB: Yes
-->
  user-replacable violation handler, over how detected logic errors are dealt
  with, e.g., logging and terminating, logging and somehow continuing, etc.. If
  an exception trying to escape a `[[throws_nothing]]` function were treated as
  a contract violation, the same control would be afforded the user of this
  feature. Thus, in addition to propagate or terminate, an integrated facility
  might also have a convert-to-violation mode.

* Integration between `[[throws_nothing]]` and contract annotations is more
  seamless if their syntaxes are harmonized. If contracts end up using a
  non-attribute syntax, then *throws-nothing* might use a similar syntax
  (assuming the two features first ship in the same standard). As described
  earlier, `[[throws_nothing]]` cannot go at the end of a function declaration
  (my preferred position) and still appertain to the function, in today's C++.
  Pre- and post-condition annotations will almost certainly go after the
  function declaration, however, so `[[throws_nothing]]` could conceivably go
  along for the ride.
<!--
  JMB: In this sense, `throws_nothing` can be viewed as another shorthand for
       a check on the caller-callee interface that is very simlar to
       `pre` and `post`, but simply evaluates its check at a distinct time
       --- when an exception escapes from a function.
 -->       

* In a build mode where contract-checks are enabled and a throwing
  contract-violation handler is installed, the programmer would want
  contract-violation exceptions to be allowed to escape a `[[throws_nothing]]`,
  rather than terminating. If we integrate `[[throws_nothing]]` with contracts,
  the compiler could automatically figure out that we are using a
  contract-checking build mode and allow exceptions to escape a
  `[[throws_nothing]]` function.  A high-quality implementation could recognize
  the interaction such that exceptions thrown from the contract-violation
  handler are propagated unchanged and other exceptions are not.
<!--
 JMB: What is a contract-violation exception?
      The thought of treating exceptions that originate from within a violation
      handler as special is... disquieting.  Making that implementation-defined
      seems drastically worse.

      Allowing this sort of thing also removes any codegen benefit again,
      so i'm not sure why users of this annotation would want that.
-->      

* If contract annotations are given additional controls, many of those controls
  might also apply to `[[throws_nothing]]`:

```C++
void f(int) [[ throws_nothing ]];          // Obey global build mode
void g(int) [[ throws_nothing audit ]];    // Only observed in audit build mode
void h(int) [[ throws_nothing enforce ]];  // Always enforced
void j(int) [[ throws_nothing assume ]];   // Assume no-throw; don't check
```

<!--
  MG: Here you use "no-throw" with hyphen, but in a couple of places earlier 
      on you used "nothrow" without a hyphen.
-->

The final line above (function `j`) would generate the smallest code because
neither the caller nor callee would need to generate any exception-handling
code. It is also the least safe because, just as in the case of other contract
annotations, assuming something that turns out to be false can easily result in
(language) undefined behavior.
<!--
 JMB: "can easily result" is too soft.  This would be explicitly making it
      UB if there is a thrown exception.
 -->      

Effects on the Standard library
===============================

No changes would be needed immediately in the Standard Library if this facility
were adopted. If LWG can discuss whether to replace or augment "*Throws*:
<!--
  MG: Starting with "If" implies there must be a "then ..." clause.
      Did you mean just "LWG can discuss" rather than "If LWG can discuss" ?
-->
nothing" in the description with `[[throws_nothing]]` in the interface of
<!--
  MG: fixed spelling
-->
functions having narrow contracts that promise not to throw when called in
contract.

The one place where immediate change might be necessary is that if there are
any narrow-contract functions targeted for C++26 that are currently annotated
with `noexcept`, we probably want to change those annotations to
`[[throws_nothing]]` or say nothing at all and leave it up to the
implementation whether to use `[[throws_nothing]]`.  Violations of the Lakos
Rule already in C++23 could be handled on a case-by-case basis (via
DR). Minimizing such violations would result in greater stability across
implementations and versions of the Standard.


Implementation Experience
=========================

At present, no compilers implement this feature. If this paper receives a
favorable response in EWGI, we will make sure to implement it before presenting
<!--
  MG: suggest just "we will implement it" ("make sure to" does not add value)
-->
it to EWG. Implementation is expected to be a fairly simple delta on the
existing implementation of `noexcept`.


Formal wording
==============

TBD: Wording will be provided after EWGI shows initial interest, i.e., after a
positive result in an "encourages more work" poll.


<!--
JMB: Questions as I ponder the wording a little:
     1. does this attribute make a thing non-trivial?  Can it be placed on a defaulted special member function?
     2. ill-formed or well-formed to put this on a functino that is `noexcept`?

     Wording basically needs a sentence in [except.spec]p5 about it being implementation defined what happens
     when the outermost block of a function with this attribute is reached when searching for an exception
     handler.  Then you just need a dcl.attr.throws_nothing section --- probably similar in a lot of ways to the noreturn
     section.
-->

<!--
JMB: After reading this, I feel like you made a strong case for why this doesn't have the same
    problems as `noexcept`, but I fail to see the parts where you have given any reasonable case for
    making use of this attribtue.  Why should I complicate by code for this?

    If the only motivation is codegen, then I think that needs to be spelled out more.  If there is
    more than that then it needs to be laid out.
-->    


 